<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pt"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>GraphicGraph.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">src-test (6 de jul. de 2023 19:58:26)</a> &gt; <a href="../../index.html" class="el_group">mc646-projeto-gs-core</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">org.graphstream.ui.graphicGraph</a> &gt; <span class="el_source">GraphicGraph.java</span></div><h1>GraphicGraph.java</h1><pre class="source lang-java linenums">/*
 * This file is part of GraphStream &lt;http://graphstream-project.org&gt;.
 * 
 * GraphStream is a library whose purpose is to handle static or dynamic
 * graph, create them from scratch, file or any source and display them.
 * 
 * This program is free software distributed under the terms of two licenses, the
 * CeCILL-C license that fits European law, and the GNU Lesser General Public
 * License. You can  use, modify and/ or redistribute the software under the terms
 * of the CeCILL-C license as circulated by CEA, CNRS and INRIA at the following
 * URL &lt;http://www.cecill.info&gt; or under the terms of the GNU LGPL as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 * 
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C and LGPL licenses and that you accept their terms.
 */

/**
 * @since 2009-07-05
 * 
 * @author Guilhelm Savin &lt;guilhelm.savin@graphstream-project.org&gt;
 * @author Antoine Dutot &lt;antoine.dutot@graphstream-project.org&gt;
 * @author Yoann Pign√© &lt;yoann.pigne@graphstream-project.org&gt;
 * @author Stefan Balev &lt;stefan.balev@graphstream-project.org&gt;
 * @author Richard O. Legendi &lt;richard.legendi@gmail.com&gt;
 * @author Alex Bowen &lt;bowen.a@gmail.com&gt;
 * @author Ben Wiederhake &lt;BenWiederhake.GitHub@gmx&gt;
 * @author kitskub &lt;kitskub@gmail.com&gt;
 * @author Hicham Brahimi &lt;hicham.brahimi@graphstream-project.org&gt;
 */
package org.graphstream.ui.graphicGraph;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;

import org.graphstream.graph.Edge;
import org.graphstream.graph.EdgeFactory;
import org.graphstream.graph.Element;
import org.graphstream.graph.ElementNotFoundException;
import org.graphstream.graph.Graph;
import org.graphstream.graph.IdAlreadyInUseException;
import org.graphstream.graph.Node;
import org.graphstream.graph.NodeFactory;
import org.graphstream.graph.implementations.AbstractElement;
import org.graphstream.stream.AttributeSink;
import org.graphstream.stream.ElementSink;
import org.graphstream.stream.Sink;
import org.graphstream.stream.SourceBase.ElementType;
import org.graphstream.stream.file.FileSink;
import org.graphstream.stream.file.FileSource;
import org.graphstream.ui.geom.Point3;
import org.graphstream.ui.graphicGraph.stylesheet.Style;
import org.graphstream.ui.graphicGraph.stylesheet.StyleConstants;
import org.graphstream.ui.graphicGraph.stylesheet.StyleConstants.Units;
import org.graphstream.ui.graphicGraph.stylesheet.StyleSheet;
import org.graphstream.ui.graphicGraph.stylesheet.Value;
import org.graphstream.ui.graphicGraph.stylesheet.Values;
import org.graphstream.ui.view.Viewer;
import org.graphstream.util.GraphListeners;

/**
 * Graph representation used in display classes.
 * &lt;p&gt;
 * &lt;p&gt;
 * Warning: This class is NOT a general graph class, and it should NOT be used
 * as it. This class is particularly dedicated to fast drawing of the graph and
 * is internally arranged to be fast for this task only. It implements graph
 * solely to be easily susceptible to be used as a sink and source for graph
 * events. Some of the common methods of the Graph interface are not functional
 * and will throw an exception if used (as documented in their respective
 * JavaDoc).
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * The purpose of the graphic graph is to represent a graph with some often used
 * graphic attributes (like position, label, etc.) stored as fields in the nodes
 * and edges and most of the style stored in styles pertaining to a style sheet
 * that tries to imitate the way CSS works. For example, the GraphicNode class
 * defines a label, a position (x,y,z) and a style that is taken from the style
 * sheet.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * The style sheet is uploaded on the graph using an attribute correspondingly
 * named &quot;stylesheet&quot; or &quot;ui.stylesheet&quot; (the second one is better). It can be a
 * string that contains the whole style sheet, or an URL of the form :
 * &lt;/p&gt;
 * &lt;p&gt;
 * 
 * &lt;pre&gt;
 * url(name)
 * &lt;/pre&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * The graphic graph does not completely duplicate a graph, it only store things
 * that are useful for drawing it. Although it implements &quot;Graph&quot;, some methods
 * are not implemented and will throw a runtime exception. These methods are
 * mostly utility methods like write(), read(), and naturally display().
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * The graphic graph has the ability to store attributes like any other graph
 * element, however the attributes stored by the graphic graph are restricted.
 * There is a filter on the attribute adding methods that let pass only:
 * &lt;ul&gt;
 * &lt;li&gt;All attributes starting with &quot;ui.&quot;.&lt;/li&gt;
 * &lt;li&gt;The &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;xy&quot; and &quot;xyz&quot; attributes.&lt;/li&gt;
 * &lt;li&gt;The &quot;stylesheet&quot; attribute (although &quot;ui.stylesheet&quot; is preferred).&lt;/li&gt;
 * &lt;li&gt;The &quot;label&quot; attribute.&lt;/li&gt;
 * &lt;/ul&gt;
 * All other attributes are filtered and not stored. The result is that if the
 * graphic graph is used as an input (a source of graph events) some attributes
 * will not pass through the filter.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * The implementation of this graph relies on the StyleGroupSet class and this
 * is indeed its way to store its elements (grouped by style and Z level).
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;p&gt;
 * In addition to this, it provides, as all graphs do, the relational
 * information for edges.
 * &lt;/p&gt;
 * &lt;p&gt;
 * TODO : this graph cannot handle modification inside event listener methods !!
 */
public class GraphicGraph extends AbstractElement implements Graph, StyleGroupListener {

	/**
	 * class level logger
	 */
<span class="nc" id="L151">	private static final Logger logger = Logger.getLogger(GraphicGraph.class.getSimpleName());</span>

	/**
	 * Set of styles.
	 */
	protected StyleSheet styleSheet;

	/**
	 * Associate graphic elements with styles.
	 */
	protected StyleGroupSet styleGroups;

	/**
	 * Connectivity. The way nodes are connected one with another via edges. The map
	 * is sorted by node. For each node an array of edges lists the connectivity.
	 */
	protected final Map&lt;GraphicNode, List&lt;GraphicEdge&gt;&gt; connectivity;

	/**
	 * The style of this graph. This is a shortcut to avoid searching it in the
	 * style sheet.
	 */
	public StyleGroup style;

	/**
	 * Memorize the step events.
	 */
<span class="nc" id="L178">	public double step = 0;</span>

	/**
	 * Set to true each time the graph was modified internally and a redraw is
	 * needed.
	 */
	public boolean graphChanged;

	/**
	 * Set to true each time a sprite or node moved.
	 */
<span class="nc" id="L189">	protected boolean boundsChanged = true;</span>

	/**
	 * Maximum position of a node or sprite in the graphic graph. Computed by
	 * {@link #computeBounds()}.
	 */
<span class="nc" id="L195">	protected Point3 hi = new Point3();</span>

	/**
	 * Minimum position of a node or sprite in the graphic graph. Computed by
	 * {@link #computeBounds()}.
	 */
<span class="nc" id="L201">	protected Point3 lo = new Point3();</span>

	/**
	 * Set of listeners of this graph.
	 */
	protected GraphListeners listeners;

	/**
	 * Time of other known sources.
	 */
	// protected SinkTime sinkTime = new SinkTime();

	/**
	 * Report back the XYZ events on nodes and sprites? If enabled, each change in
	 * the position of nodes and sprites will be sent to potential listeners of the
	 * graph. By default this is disabled as long there are no listeners.
	 */
<span class="nc" id="L218">	protected boolean feedbackXYZ = true;</span>

	/**
	 * New empty graphic graph.
	 * &lt;p&gt;
	 * A default style sheet is created, it then can be &quot;cascaded&quot; with other style
	 * sheets.
	 */
	public GraphicGraph(String id) {
<span class="nc" id="L227">		super(id);</span>

<span class="nc" id="L229">		listeners = new GraphListeners(this);</span>
<span class="nc" id="L230">		styleSheet = new StyleSheet();</span>
<span class="nc" id="L231">		styleGroups = new StyleGroupSet(styleSheet);</span>
<span class="nc" id="L232">		connectivity = new HashMap&lt;GraphicNode, List&lt;GraphicEdge&gt;&gt;();</span>

<span class="nc" id="L234">		styleGroups.addListener(this);</span>
<span class="nc" id="L235">		styleGroups.addElement(this); // Add style to this graph.</span>

<span class="nc" id="L237">		style = styleGroups.getStyleFor(this);</span>
<span class="nc" id="L238">	}</span>

	// Access

	/**
	 * True if the graph was edited or changed in any way since the last reset of
	 * the &quot;changed&quot; flag.
	 *
	 * @return true if the graph was changed.
	 */
	public boolean graphChangedFlag() {
<span class="nc" id="L249">		return graphChanged;</span>
	}

	/**
	 * Reset the &quot;changed&quot; flag.
	 *
	 * @see #graphChangedFlag()
	 */
	public void resetGraphChangedFlag() {
<span class="nc" id="L258">		graphChanged = false;</span>
<span class="nc" id="L259">	}</span>

	/**
	 * The style sheet. This style sheet is the result of the &quot;cascade&quot; or
	 * accumulation of styles added via attributes of the graph.
	 *
	 * @return A style sheet.
	 */
	public StyleSheet getStyleSheet() {
<span class="nc" id="L268">		return styleSheet;</span>
	}

	/**
	 * The graph style group.
	 *
	 * @return A style group.
	 */
	public StyleGroup getStyle() {
<span class="nc" id="L277">		return style;</span>
	}

	/**
	 * The complete set of style groups.
	 *
	 * @return The style groups.
	 */
	public StyleGroupSet getStyleGroups() {
<span class="nc" id="L286">		return styleGroups;</span>
	}

	@Override
	public String toString() {
<span class="nc" id="L291">		return String.format(&quot;[%s %d nodes %d edges]&quot;, getId(), getNodeCount(), getEdgeCount());</span>
	}

	public double getStep() {
<span class="nc" id="L295">		return step;</span>
	}

	/**
	 * The maximum position of a node or sprite. Notice that this is updated only
	 * each time the {@link #computeBounds()} method is called.
	 *
	 * @return The maximum node or sprite position.
	 */
	public Point3 getMaxPos() {
<span class="nc" id="L305">		return hi;</span>
	}

	/**
	 * The minimum position of a node or sprite. Notice that this is updated only
	 * each time the {@link #computeBounds()} method is called.
	 *
	 * @return The minimum node or sprite position.
	 */
	public Point3 getMinPos() {
<span class="nc" id="L315">		return lo;</span>
	}

	/**
	 * Does the graphic graph publish via attribute changes the XYZ changes on nodes
	 * and sprites when changed ?. This is disabled by default, and enabled as soon
	 * as there is at least one listener.
	 */
	public boolean feedbackXYZ() {
<span class="nc" id="L324">		return feedbackXYZ;</span>
	}

	// Command

	/**
	 * Should the graphic graph publish via attribute changes the XYZ changes on
	 * nodes and sprites when changed ?.
	 */
	public void feedbackXYZ(boolean on) {
<span class="nc" id="L334">		feedbackXYZ = on;</span>
<span class="nc" id="L335">	}</span>

	/**
	 * Compute the overall bounds of the graphic graph according to the nodes and
	 * sprites positions. We can only compute the graph bounds from the nodes and
	 * sprites centres since the node and graph bounds may in certain circumstances
	 * be computed according to the graph bounds. The bounds are stored in the graph
	 * metrics.
	 * &lt;p&gt;
	 * This operation will process each node and sprite and is therefore costly.
	 * However it does this computation again only when a node or sprite moved.
	 * Therefore it can be called several times, if nothing moved in the graph, the
	 * computation will not be redone.
	 *
	 * @see #getMaxPos()
	 * @see #getMinPos()
	 */
	public void computeBounds() {
<span class="nc bnc" id="L353" title="All 2 branches missed.">		if (boundsChanged) {</span>
<span class="nc" id="L354">			final AtomicBoolean effectiveChange = new AtomicBoolean(false);</span>

<span class="nc" id="L356">			lo.x = lo.y = lo.z = Double.MAX_VALUE;</span>
<span class="nc" id="L357">			hi.x = hi.y = hi.z = -Double.MAX_VALUE;</span>

<span class="nc" id="L359">			nodes().forEach(n -&gt; {</span>
<span class="nc" id="L360">				GraphicNode node = (GraphicNode) n;</span>

<span class="nc bnc" id="L362" title="All 4 branches missed.">				if (!node.hidden &amp;&amp; node.positionned) {</span>
<span class="nc" id="L363">					effectiveChange.set(true);</span>

<span class="nc bnc" id="L365" title="All 2 branches missed.">					if (node.x &lt; lo.x)</span>
<span class="nc" id="L366">						lo.x = node.x;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">					if (node.x &gt; hi.x)</span>
<span class="nc" id="L368">						hi.x = node.x;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">					if (node.y &lt; lo.y)</span>
<span class="nc" id="L370">						lo.y = node.y;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">					if (node.y &gt; hi.y)</span>
<span class="nc" id="L372">						hi.y = node.y;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">					if (node.z &lt; lo.z)</span>
<span class="nc" id="L374">						lo.z = node.z;</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">					if (node.z &gt; hi.z)</span>
<span class="nc" id="L376">						hi.z = node.z;</span>
				}
<span class="nc" id="L378">			});</span>

<span class="nc" id="L380">			sprites().forEach(sprite -&gt; {</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">				if (!sprite.isAttached() &amp;&amp; sprite.getUnits() == StyleConstants.Units.GU) {</span>
<span class="nc" id="L382">					double x = sprite.getX();</span>
<span class="nc" id="L383">					double y = sprite.getY();</span>
<span class="nc" id="L384">					double z = sprite.getZ();</span>

<span class="nc bnc" id="L386" title="All 2 branches missed.">					if (!sprite.hidden) {</span>
<span class="nc" id="L387">						effectiveChange.set(true);</span>

<span class="nc bnc" id="L389" title="All 2 branches missed.">						if (x &lt; lo.x)</span>
<span class="nc" id="L390">							lo.x = x;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">						if (x &gt; hi.x)</span>
<span class="nc" id="L392">							hi.x = x;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">						if (y &lt; lo.y)</span>
<span class="nc" id="L394">							lo.y = y;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">						if (y &gt; hi.y)</span>
<span class="nc" id="L396">							hi.y = y;</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">						if (z &lt; lo.z)</span>
<span class="nc" id="L398">							lo.z = z;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">						if (z &gt; hi.z)</span>
<span class="nc" id="L400">							hi.z = z;</span>
					}
				}
<span class="nc" id="L403">			});</span>

<span class="nc bnc" id="L405" title="All 2 branches missed.">			if (hi.x - lo.x &lt; 0.000001) {</span>
<span class="nc" id="L406">				hi.x = hi.x + 1;</span>
<span class="nc" id="L407">				lo.x = lo.x - 1;</span>
			}
<span class="nc bnc" id="L409" title="All 2 branches missed.">			if (hi.y - lo.y &lt; 0.000001) {</span>
<span class="nc" id="L410">				hi.y = hi.y + 1;</span>
<span class="nc" id="L411">				lo.y = lo.y - 1;</span>
			}
<span class="nc bnc" id="L413" title="All 2 branches missed.">			if (hi.z - lo.z &lt; 0.000001) {</span>
<span class="nc" id="L414">				hi.z = hi.z + 1;</span>
<span class="nc" id="L415">				lo.z = lo.z - 1;</span>
			}

			//
			// Prevent infinities that can be produced by Double.MAX_VALUE.
			//
<span class="nc bnc" id="L421" title="All 2 branches missed.">			if (effectiveChange.get())</span>
<span class="nc" id="L422">				boundsChanged = false;</span>
			else {
<span class="nc" id="L424">				lo.x = lo.y = lo.z = -1;</span>
<span class="nc" id="L425">				hi.x = hi.y = hi.z = 1;</span>
			}
		}
<span class="nc" id="L428">	}</span>

	protected void moveNode(String id, double x, double y, double z) {
<span class="nc" id="L431">		GraphicNode node = (GraphicNode) styleGroups.getNode(id);</span>

<span class="nc bnc" id="L433" title="All 2 branches missed.">		if (node != null) {</span>
<span class="nc" id="L434">			node.x = x;</span>
<span class="nc" id="L435">			node.y = y;</span>
<span class="nc" id="L436">			node.z = z;</span>
<span class="nc" id="L437">			node.setAttribute(&quot;x&quot;, x);</span>
<span class="nc" id="L438">			node.setAttribute(&quot;y&quot;, y);</span>
<span class="nc" id="L439">			node.setAttribute(&quot;z&quot;, z);</span>

<span class="nc" id="L441">			graphChanged = true;</span>
		}
<span class="nc" id="L443">	}</span>

	@Override
	public Node getNode(String id) {
<span class="nc" id="L447">		return styleGroups.getNode(id);</span>
	}

	@Override
	public Edge getEdge(String id) {
<span class="nc" id="L452">		return styleGroups.getEdge(id);</span>
	}

	public GraphicSprite getSprite(String id) {
<span class="nc" id="L456">		return styleGroups.getSprite(id);</span>
	}

	@Override
	protected void attributeChanged(AttributeChangeEvent event, String attribute, Object oldValue, Object newValue) {

		// One of the most important method. Most of the communication comes
		// from attributes.

<span class="nc bnc" id="L465" title="All 2 branches missed.">		if (attribute.equals(&quot;ui.repaint&quot;)) {</span>
<span class="nc" id="L466">			graphChanged = true;</span>
<span class="nc bnc" id="L467" title="All 4 branches missed.">		} else if (attribute.equals(&quot;ui.stylesheet&quot;) || attribute.equals(&quot;stylesheet&quot;)) {</span>
<span class="nc bnc" id="L468" title="All 4 branches missed.">			if (event == AttributeChangeEvent.ADD || event == AttributeChangeEvent.CHANGE) {</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">				if (newValue instanceof String) {</span>
					try {
<span class="nc" id="L471">						styleSheet.load((String) newValue);</span>
<span class="nc" id="L472">						graphChanged = true;</span>
<span class="nc" id="L473">					} catch (Exception e) {</span>
<span class="nc" id="L474">						logger.log(Level.WARNING,</span>
<span class="nc" id="L475">								String.format(&quot;Error while parsing style sheet for graph '%s'.&quot;, getId()), e);</span>
					}
<span class="nc" id="L477">				} else {</span>
<span class="nc" id="L478">					logger.warning(</span>
<span class="nc" id="L479">							String.format(&quot;Error with stylesheet specification what to do with '%s'.&quot;, newValue));</span>
				}
<span class="nc" id="L481">			} else // Remove the style.</span>
			{
<span class="nc" id="L483">				styleSheet.clear();</span>
<span class="nc" id="L484">				graphChanged = true;</span>
			}
<span class="nc bnc" id="L486" title="All 2 branches missed.">		} else if (attribute.startsWith(&quot;ui.sprite.&quot;)) {</span>
			// Defers the sprite handling to the sprite API.
<span class="nc" id="L488">			spriteAttribute(event, null, attribute, newValue);</span>
<span class="nc" id="L489">			graphChanged = true;</span>
		}

<span class="nc" id="L492">		listeners.sendAttributeChangedEvent(getId(), ElementType.GRAPH, attribute, event, oldValue, newValue);</span>
<span class="nc" id="L493">	}</span>

	/**
	 * Display the node/edge relations.
	 */
	public void printConnectivity() {
<span class="nc" id="L499">		Iterator&lt;GraphicNode&gt; keys = connectivity.keySet().iterator();</span>

<span class="nc" id="L501">		System.err.printf(&quot;Graphic graph connectivity:%n&quot;);</span>

<span class="nc bnc" id="L503" title="All 2 branches missed.">		while (keys.hasNext()) {</span>
<span class="nc" id="L504">			GraphicNode node = keys.next();</span>
<span class="nc" id="L505">			System.err.printf(&quot;    [%s] -&gt; &quot;, node.getId());</span>
<span class="nc" id="L506">			Iterable&lt;GraphicEdge&gt; edges = connectivity.get(node);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">			for (GraphicEdge edge : edges)</span>
<span class="nc" id="L508">				System.err.printf(&quot; (%s %d)&quot;, edge.getId(), edge.getMultiIndex());</span>
<span class="nc" id="L509">			System.err.printf(&quot;%n&quot;);</span>
		}
<span class="nc" id="L511">	}</span>

	// Style group listener interface

	public void elementStyleChanged(Element element, StyleGroup oldStyle, StyleGroup style) {
<span class="nc bnc" id="L516" title="All 2 branches missed.">		if (element instanceof GraphicElement) {</span>
<span class="nc" id="L517">			GraphicElement ge = (GraphicElement) element;</span>
<span class="nc" id="L518">			ge.style = style;</span>
<span class="nc" id="L519">			graphChanged = true;</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">		} else if (element instanceof GraphicGraph) {</span>
<span class="nc" id="L521">			GraphicGraph gg = (GraphicGraph) element;</span>
<span class="nc" id="L522">			gg.style = style;</span>
<span class="nc" id="L523">			graphChanged = true;</span>
<span class="nc" id="L524">		} else {</span>
<span class="nc" id="L525">			throw new RuntimeException(&quot;WTF ?&quot;);</span>
		}
<span class="nc" id="L527">	}</span>

	public void styleChanged(StyleGroup style) {

<span class="nc" id="L531">	}</span>

	// Graph interface

	@Override
	public Stream&lt;Node&gt; nodes() {
<span class="nc" id="L537">		return styleGroups.nodes();</span>
	}

	@Override
	public Stream&lt;Edge&gt; edges() {
<span class="nc" id="L542">		return styleGroups.edges();</span>
	}

	public Stream&lt;GraphicSprite&gt; sprites() {
<span class="nc" id="L546">		return styleGroups.sprites();</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	public Iterator&lt;Node&gt; iterator() {
<span class="nc" id="L551">		return (Iterator&lt;Node&gt;) styleGroups.getNodeIterator();</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.stream.Source#addSink(org.graphstream.stream.Sink)
	 */
	public void addSink(Sink listener) {
<span class="nc" id="L560">		listeners.addSink(listener);</span>
<span class="nc" id="L561">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.stream.Source#removeSink(org.graphstream.stream.Sink)
	 */
	public void removeSink(Sink listener) {
<span class="nc" id="L569">		listeners.removeSink(listener);</span>
<span class="nc" id="L570">	}</span>

	/*
	 * *(non-Javadoc)
	 * 
	 * @see org.graphstream.stream.Source#addAttributeSink(org.graphstream.stream
	 * .AttributeSink)
	 */
	public void addAttributeSink(AttributeSink listener) {
<span class="nc" id="L579">		listeners.addAttributeSink(listener);</span>
<span class="nc" id="L580">	}</span>

	/*
	 * *(non-Javadoc)
	 * 
	 * @see org.graphstream.stream.Source#removeAttributeSink(org.graphstream.stream
	 * .AttributeSink)
	 */
	public void removeAttributeSink(AttributeSink listener) {
<span class="nc" id="L589">		listeners.removeAttributeSink(listener);</span>
<span class="nc" id="L590">	}</span>

	/*
	 * *(non-Javadoc)
	 * 
	 * @see org.graphstream.stream.Source#addElementSink(org.graphstream.stream.
	 * ElementSink)
	 */
	public void addElementSink(ElementSink listener) {
<span class="nc" id="L599">		listeners.addElementSink(listener);</span>
<span class="nc" id="L600">	}</span>

	/*
	 * *(non-Javadoc)
	 * 
	 * @see org.graphstream.stream.Source#removeElementSink(org.graphstream.stream
	 * .ElementSink)
	 */
	public void removeElementSink(ElementSink listener) {
<span class="nc" id="L609">		listeners.removeElementSink(listener);</span>
<span class="nc" id="L610">	}</span>

	/*
	 * *(non-Javadoc)
	 * 
	 * @see org.graphstream.graph.Graph#attributeSinks()
	 */
	public Iterable&lt;AttributeSink&gt; attributeSinks() {
<span class="nc" id="L618">		return listeners.attributeSinks();</span>
	}

	/*
	 * *(non-Javadoc)
	 * 
	 * @see org.graphstream.graph.Graph#elementSinks()
	 */
	public Iterable&lt;ElementSink&gt; elementSinks() {
<span class="nc" id="L627">		return listeners.elementSinks();</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.graph.Graph#addEdge(java.lang.String, java.lang.String,
	 * java.lang.String, boolean)
	 */
	@Override
	public Edge addEdge(String id, String from, String to, boolean directed)
			throws IdAlreadyInUseException, ElementNotFoundException {
<span class="nc" id="L639">		GraphicEdge edge = (GraphicEdge) styleGroups.getEdge(id);</span>

<span class="nc bnc" id="L641" title="All 2 branches missed.">		if (edge == null) {</span>
<span class="nc" id="L642">			GraphicNode n1 = (GraphicNode) styleGroups.getNode(from);</span>
<span class="nc" id="L643">			GraphicNode n2 = (GraphicNode) styleGroups.getNode(to);</span>

<span class="nc bnc" id="L645" title="All 2 branches missed.">			if (n1 == null)</span>
<span class="nc" id="L646">				throw new ElementNotFoundException(&quot;node \&quot;%s\&quot;&quot;, from);</span>

<span class="nc bnc" id="L648" title="All 2 branches missed.">			if (n2 == null)</span>
<span class="nc" id="L649">				throw new ElementNotFoundException(&quot;node \&quot;%s\&quot;&quot;, to);</span>

<span class="nc" id="L651">			edge = new GraphicEdge(id, n1, n2, directed, null);// , attributes);</span>

<span class="nc" id="L653">			styleGroups.addElement(edge);</span>

<span class="nc" id="L655">			List&lt;GraphicEdge&gt; l1 = connectivity.get(n1);</span>
<span class="nc" id="L656">			List&lt;GraphicEdge&gt; l2 = connectivity.get(n2);</span>

<span class="nc bnc" id="L658" title="All 2 branches missed.">			if (l1 == null) {</span>
<span class="nc" id="L659">				l1 = new ArrayList&lt;GraphicEdge&gt;();</span>
<span class="nc" id="L660">				connectivity.put(n1, l1);</span>
			}

<span class="nc bnc" id="L663" title="All 2 branches missed.">			if (l2 == null) {</span>
<span class="nc" id="L664">				l2 = new ArrayList&lt;GraphicEdge&gt;();</span>
<span class="nc" id="L665">				connectivity.put(n2, l2);</span>
			}

<span class="nc" id="L668">			l1.add(edge);</span>
<span class="nc" id="L669">			l2.add(edge);</span>
<span class="nc" id="L670">			edge.countSameEdges(l1);</span>

<span class="nc" id="L672">			graphChanged = true;</span>

<span class="nc" id="L674">			listeners.sendEdgeAdded(id, from, to, directed);</span>
		}

<span class="nc" id="L677">		return edge;</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.graph.Graph#addNode(java.lang.String)
	 */
	@Override
	public Node addNode(String id) throws IdAlreadyInUseException {
<span class="nc" id="L687">		GraphicNode node = (GraphicNode) styleGroups.getNode(id);</span>

<span class="nc bnc" id="L689" title="All 2 branches missed.">		if (node == null) {</span>
<span class="nc" id="L690">			node = new GraphicNode(this, id, null);// , attributes);</span>

<span class="nc" id="L692">			styleGroups.addElement(node);</span>

<span class="nc" id="L694">			graphChanged = true;</span>

<span class="nc" id="L696">			listeners.sendNodeAdded(id);</span>
		}

<span class="nc" id="L699">		return node;</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.graph.Graph#clear()
	 */
	@Override
	public void clear() {
<span class="nc" id="L709">		listeners.sendGraphCleared();</span>

<span class="nc" id="L711">		clearAttributesWithNoEvent();</span>

<span class="nc" id="L713">		connectivity.clear();</span>
<span class="nc" id="L714">		styleGroups.clear();</span>
<span class="nc" id="L715">		styleSheet.clear();</span>

<span class="nc" id="L717">		step = 0;</span>
<span class="nc" id="L718">		graphChanged = true;</span>

<span class="nc" id="L720">		styleGroups.addElement(this);</span>
<span class="nc" id="L721">		style = styleGroups.getStyleFor(this);</span>
<span class="nc" id="L722">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.graph.Graph#removeEdge(java.lang.String)
	 */
	@Override
	public Edge removeEdge(String id) throws ElementNotFoundException {
<span class="nc" id="L731">		GraphicEdge edge = (GraphicEdge) styleGroups.getEdge(id);</span>

<span class="nc bnc" id="L733" title="All 2 branches missed.">		if (edge != null) {</span>
<span class="nc" id="L734">			listeners.sendEdgeRemoved(id);</span>

<span class="nc bnc" id="L736" title="All 2 branches missed.">			if (connectivity.get(edge.from) != null)</span>
<span class="nc" id="L737">				connectivity.get(edge.from).remove(edge);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">			if (connectivity.get(edge.to) != null)</span>
<span class="nc" id="L739">				connectivity.get(edge.to).remove(edge);</span>

<span class="nc" id="L741">			styleGroups.removeElement(edge);</span>
<span class="nc" id="L742">			edge.removed();</span>

<span class="nc" id="L744">			graphChanged = true;</span>
		}

<span class="nc" id="L747">		return edge;</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.graph.Graph#removeEdge(java.lang.String,
	 * java.lang.String)
	 */
	@Override
	public Edge removeEdge(String from, String to) throws ElementNotFoundException {
<span class="nc" id="L758">		GraphicNode node0 = (GraphicNode) styleGroups.getNode(from);</span>
<span class="nc" id="L759">		GraphicNode node1 = (GraphicNode) styleGroups.getNode(to);</span>

<span class="nc bnc" id="L761" title="All 4 branches missed.">		if (node0 != null &amp;&amp; node1 != null) {</span>
<span class="nc" id="L762">			Collection&lt;GraphicEdge&gt; edges0 = connectivity.get(node0);</span>
<span class="nc" id="L763">			Collection&lt;GraphicEdge&gt; edges1 = connectivity.get(node1);</span>

<span class="nc bnc" id="L765" title="All 2 branches missed.">			for (GraphicEdge edge0 : edges0) {</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">				for (GraphicEdge edge1 : edges1) {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">					if (edge0 == edge1) {</span>
<span class="nc" id="L768">						removeEdge(edge0.getId());</span>
<span class="nc" id="L769">						return edge0;</span>
					}
				}
			}
		}

<span class="nc" id="L775">		return null;</span>
	}

	/*
	 * *(non-Javadoc)
	 * 
	 * @see org.graphstream.graph.Graph#removeNode(java.lang.String)
	 */
	@Override
	public Node removeNode(String id) throws ElementNotFoundException {
<span class="nc" id="L785">		GraphicNode node = (GraphicNode) styleGroups.getNode(id);</span>

<span class="nc bnc" id="L787" title="All 2 branches missed.">		if (node != null) {</span>
<span class="nc" id="L788">			listeners.sendNodeRemoved(id);</span>

<span class="nc bnc" id="L790" title="All 2 branches missed.">			if (connectivity.get(node) != null) {</span>
				// We must do a copy of the connectivity set for the node
				// since we will be modifying the connectivity as we process
				// edges.
<span class="nc" id="L794">				List&lt;GraphicEdge&gt; l = new ArrayList&lt;GraphicEdge&gt;(connectivity.get(node));</span>

<span class="nc bnc" id="L796" title="All 2 branches missed.">				for (GraphicEdge edge : l)</span>
<span class="nc" id="L797">					removeEdge(edge.getId());</span>

<span class="nc" id="L799">				connectivity.remove(node);</span>
			}

<span class="nc" id="L802">			styleGroups.removeElement(node);</span>
<span class="nc" id="L803">			node.removed();</span>

<span class="nc" id="L805">			graphChanged = true;</span>
		}

<span class="nc" id="L808">		return node;</span>
	}

	public Viewer display() {
<span class="nc" id="L812">		throw new RuntimeException(&quot;GraphicGraph is used by display() and cannot recursively define display()&quot;);</span>
	}

	public Viewer display(boolean autoLayout) {
<span class="nc" id="L816">		throw new RuntimeException(&quot;GraphicGraph is used by display() and cannot recursively define display()&quot;);</span>
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.graph.Graph#stepBegins(double)
	 */
	@Override
	public void stepBegins(double step) {
<span class="nc" id="L826">		listeners.sendStepBegins(step);</span>
<span class="nc" id="L827">		this.step = step;</span>
<span class="nc" id="L828">	}</span>

	@Override
	public EdgeFactory&lt;? extends Edge&gt; edgeFactory() {
<span class="nc" id="L832">		throw new RuntimeException(&quot;GraphicGraph does not support EdgeFactory&quot;);</span>
	}

	@Override
	public int getEdgeCount() {
<span class="nc" id="L837">		return styleGroups.getEdgeCount();</span>
	}

	@Override
	public int getNodeCount() {
<span class="nc" id="L842">		return styleGroups.getNodeCount();</span>
	}

	public int getSpriteCount() {
<span class="nc" id="L846">		return styleGroups.getSpriteCount();</span>
	}

	@Override
	public boolean isAutoCreationEnabled() {
<span class="nc" id="L851">		return false;</span>
	}

	@Override
	public NodeFactory&lt;? extends Node&gt; nodeFactory() {
<span class="nc" id="L856">		throw new RuntimeException(&quot;GraphicGraph does not support NodeFactory&quot;);</span>
	}

	@Override
	public void setAutoCreate(boolean on) {
<span class="nc" id="L861">		throw new RuntimeException(&quot;GraphicGraph does not support auto-creation&quot;);</span>
	}

	@Override
	public boolean isStrict() {
<span class="nc" id="L866">		return false;</span>
	}

	@Override
	public void setStrict(boolean on) {
<span class="nc" id="L871">		throw new RuntimeException(&quot;GraphicGraph does not support strict checking&quot;);</span>
	}

	@Override
	public void setEdgeFactory(EdgeFactory&lt;? extends Edge&gt; ef) {
<span class="nc" id="L876">		throw new RuntimeException(&quot;you cannot change the edge factory for graphic graphs !&quot;);</span>
	}

	@Override
	public void setNodeFactory(NodeFactory&lt;? extends Node&gt; nf) {
<span class="nc" id="L881">		throw new RuntimeException(&quot;you cannot change the node factory for graphic graphs !&quot;);</span>
	}

	@Override
	public void read(String filename) throws IOException {
<span class="nc" id="L886">		throw new RuntimeException(&quot;GraphicGraph does not support I/O&quot;);</span>
	}

	@Override
	public void read(FileSource input, String filename) throws IOException {
<span class="nc" id="L891">		throw new RuntimeException(&quot;GraphicGraph does not support I/O&quot;);</span>
	}

	@Override
	public void write(FileSink output, String filename) throws IOException {
<span class="nc" id="L896">		throw new RuntimeException(&quot;GraphicGraph does not support I/O&quot;);</span>
	}

	@Override
	public void write(String filename) throws IOException {
<span class="nc" id="L901">		throw new RuntimeException(&quot;GraphicGraph does not support I/O&quot;);</span>
	}

	// Output interface

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.graphstream.stream.AttributeSink#edgeAttributeAdded(java.lang.String,
	 * long, java.lang.String, java.lang.String, java.lang.Object)
	 */
	@Override
	public void edgeAttributeAdded(String sourceId, long timeId, String edgeId, String attribute, Object value) {
<span class="nc" id="L915">		listeners.edgeAttributeAdded(sourceId, timeId, edgeId, attribute, value);</span>
<span class="nc" id="L916">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.graphstream.stream.AttributeSink#edgeAttributeChanged(java.lang.String ,
	 * long, java.lang.String, java.lang.String, java.lang.Object, java.lang.Object)
	 */
	@Override
	public void edgeAttributeChanged(String sourceId, long timeId, String edgeId, String attribute, Object oldValue,
			Object newValue) {
<span class="nc" id="L928">		listeners.edgeAttributeChanged(sourceId, timeId, edgeId, attribute, oldValue, newValue);</span>
<span class="nc" id="L929">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.graphstream.stream.AttributeSink#edgeAttributeRemoved(java.lang.String ,
	 * long, java.lang.String, java.lang.String)
	 */
	@Override
	public void edgeAttributeRemoved(String sourceId, long timeId, String edgeId, String attribute) {
<span class="nc" id="L940">		listeners.edgeAttributeRemoved(sourceId, timeId, edgeId, attribute);</span>
<span class="nc" id="L941">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.graphstream.stream.AttributeSink#graphAttributeAdded(java.lang.String ,
	 * long, java.lang.String, java.lang.Object)
	 */
	@Override
	public void graphAttributeAdded(String sourceId, long timeId, String attribute, Object value) {
<span class="nc" id="L952">		listeners.graphAttributeAdded(sourceId, timeId, attribute, value);</span>
<span class="nc" id="L953">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.stream.AttributeSink#graphAttributeChanged(java.lang.
	 * String, long, java.lang.String, java.lang.Object, java.lang.Object)
	 */
	@Override
	public void graphAttributeChanged(String sourceId, long timeId, String attribute, Object oldValue,
			Object newValue) {
<span class="nc" id="L964">		listeners.graphAttributeChanged(sourceId, timeId, attribute, oldValue, newValue);</span>
<span class="nc" id="L965">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.stream.AttributeSink#graphAttributeRemoved(java.lang.
	 * String, long, java.lang.String)
	 */
	@Override
	public void graphAttributeRemoved(String sourceId, long timeId, String attribute) {
<span class="nc" id="L975">		listeners.graphAttributeRemoved(sourceId, timeId, attribute);</span>
<span class="nc" id="L976">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.graphstream.stream.AttributeSink#nodeAttributeAdded(java.lang.String,
	 * long, java.lang.String, java.lang.String, java.lang.Object)
	 */
	@Override
	public void nodeAttributeAdded(String sourceId, long timeId, String nodeId, String attribute, Object value) {
<span class="nc" id="L987">		listeners.nodeAttributeAdded(sourceId, timeId, nodeId, attribute, value);</span>
<span class="nc" id="L988">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.graphstream.stream.AttributeSink#nodeAttributeChanged(java.lang.String ,
	 * long, java.lang.String, java.lang.String, java.lang.Object, java.lang.Object)
	 */
	@Override
	public void nodeAttributeChanged(String sourceId, long timeId, String nodeId, String attribute, Object oldValue,
			Object newValue) {
<span class="nc" id="L1000">		listeners.nodeAttributeChanged(sourceId, timeId, nodeId, attribute, oldValue, newValue);</span>
<span class="nc" id="L1001">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * org.graphstream.stream.AttributeSink#nodeAttributeRemoved(java.lang.String ,
	 * long, java.lang.String, java.lang.String)
	 */
	@Override
	public void nodeAttributeRemoved(String sourceId, long timeId, String nodeId, String attribute) {
<span class="nc" id="L1012">		listeners.nodeAttributeRemoved(sourceId, timeId, nodeId, attribute);</span>
<span class="nc" id="L1013">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.stream.ElementSink#edgeAdded(java.lang.String, long,
	 * java.lang.String, java.lang.String, java.lang.String, boolean)
	 */
	@Override
	public void edgeAdded(String sourceId, long timeId, String edgeId, String fromNodeId, String toNodeId,
			boolean directed) {
<span class="nc" id="L1024">		listeners.edgeAdded(sourceId, timeId, edgeId, fromNodeId, toNodeId, directed);</span>
<span class="nc" id="L1025">	}</span>

	/*
	 * *(non-Javadoc)
	 * 
	 * @see org.graphstream.stream.ElementSink#edgeRemoved(java.lang.String, long,
	 * java.lang.String)
	 */
	@Override
	public void edgeRemoved(String sourceId, long timeId, String edgeId) {
<span class="nc" id="L1035">		listeners.edgeRemoved(sourceId, timeId, edgeId);</span>
<span class="nc" id="L1036">	}</span>

	/*
	 * *(non-Javadoc)
	 * 
	 * @see org.graphstream.stream.ElementSink#graphCleared(java.lang.String, long)
	 */
	@Override
	public void graphCleared(String sourceId, long timeId) {
<span class="nc" id="L1045">		listeners.graphCleared(sourceId, timeId);</span>
<span class="nc" id="L1046">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.stream.ElementSink#nodeAdded(java.lang.String, long,
	 * java.lang.String)
	 */
	@Override
	public void nodeAdded(String sourceId, long timeId, String nodeId) {
<span class="nc" id="L1056">		listeners.nodeAdded(sourceId, timeId, nodeId);</span>
<span class="nc" id="L1057">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.stream.ElementSink#nodeRemoved(java.lang.String, long,
	 * java.lang.String)
	 */
	@Override
	public void nodeRemoved(String sourceId, long timeId, String nodeId) {
<span class="nc" id="L1067">		listeners.nodeRemoved(sourceId, timeId, nodeId);</span>
<span class="nc" id="L1068">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.stream.ElementSink#stepBegins(java.lang.String, long,
	 * double)
	 */
	@Override
	public void stepBegins(String sourceId, long timeId, double time) {
<span class="nc" id="L1078">		listeners.sendStepBegins(sourceId, timeId, time);</span>
<span class="nc" id="L1079">		stepBegins(time);</span>
<span class="nc" id="L1080">	}</span>

	// Sprite interface

	protected void spriteAttribute(AttributeChangeEvent event, Element element, String attribute, Object value) {
<span class="nc" id="L1085">		String spriteId = attribute.substring(10); // Remove the &quot;ui.sprite.&quot;</span>
		// prefix.
<span class="nc" id="L1087">		int pos = spriteId.indexOf('.'); // Look if there is something after the</span>
		// sprite id.
<span class="nc" id="L1089">		String attr = null;</span>

<span class="nc bnc" id="L1091" title="All 2 branches missed.">		if (pos &gt; 0) {</span>
<span class="nc" id="L1092">			attr = spriteId.substring(pos + 1); // Cut the sprite id.</span>
<span class="nc" id="L1093">			spriteId = spriteId.substring(0, pos); // Cut the sprite attribute</span>
			// name.
		}

<span class="nc bnc" id="L1097" title="All 2 branches missed.">		if (attr == null) {</span>
<span class="nc" id="L1098">			addOrChangeSprite(event, element, spriteId, value);</span>
<span class="nc" id="L1099">		} else {</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">			if (event == AttributeChangeEvent.ADD) {</span>
<span class="nc" id="L1101">				GraphicSprite sprite = styleGroups.getSprite(spriteId);</span>

				// We add the sprite, in case of a replay, some attributes of
				// the sprite can be
				// changed before the sprite is declared.
<span class="nc bnc" id="L1106" title="All 2 branches missed.">				if (sprite == null) {</span>
<span class="nc" id="L1107">					addOrChangeSprite(AttributeChangeEvent.ADD, element, spriteId, null);</span>
<span class="nc" id="L1108">					sprite = styleGroups.getSprite(spriteId);</span>
				}

<span class="nc" id="L1111">				sprite.setAttribute(attr, value);</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">			} else if (event == AttributeChangeEvent.CHANGE) {</span>
<span class="nc" id="L1113">				GraphicSprite sprite = styleGroups.getSprite(spriteId);</span>

<span class="nc bnc" id="L1115" title="All 2 branches missed.">				if (sprite == null) {</span>
<span class="nc" id="L1116">					addOrChangeSprite(AttributeChangeEvent.ADD, element, spriteId, null);</span>
<span class="nc" id="L1117">					sprite = styleGroups.getSprite(spriteId);</span>
				}

<span class="nc" id="L1120">				sprite.setAttribute(attr, value);</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">			} else if (event == AttributeChangeEvent.REMOVE) {</span>
<span class="nc" id="L1122">				GraphicSprite sprite = styleGroups.getSprite(spriteId);</span>

<span class="nc bnc" id="L1124" title="All 2 branches missed.">				if (sprite != null)</span>
<span class="nc" id="L1125">					sprite.removeAttribute(attr);</span>
			}
		}
<span class="nc" id="L1128">	}</span>

	protected void addOrChangeSprite(AttributeChangeEvent event, Element element, String spriteId, Object value) {

<span class="nc bnc" id="L1132" title="All 4 branches missed.">		if (event == AttributeChangeEvent.ADD || event == AttributeChangeEvent.CHANGE) {</span>
<span class="nc" id="L1133">			GraphicSprite sprite = styleGroups.getSprite(spriteId);</span>

<span class="nc bnc" id="L1135" title="All 2 branches missed.">			if (sprite == null)</span>
<span class="nc" id="L1136">				sprite = addSprite_(spriteId);</span>

<span class="nc bnc" id="L1138" title="All 2 branches missed.">			if (element != null) {</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">				if (element instanceof GraphicNode)</span>
<span class="nc" id="L1140">					sprite.attachToNode((GraphicNode) element);</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">				else if (element instanceof GraphicEdge)</span>
<span class="nc" id="L1142">					sprite.attachToEdge((GraphicEdge) element);</span>
			}

<span class="nc bnc" id="L1145" title="All 4 branches missed.">			if (value != null &amp;&amp; (!(value instanceof Boolean)))</span>
<span class="nc" id="L1146">				positionSprite(sprite, value);</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">		} else if (event == AttributeChangeEvent.REMOVE) {</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">			if (element == null) {</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">				if (styleGroups.getSprite(spriteId) != null) {</span>
<span class="nc" id="L1150">					removeSprite_(spriteId);</span>
				}
<span class="nc" id="L1152">			} else {</span>
<span class="nc" id="L1153">				GraphicSprite sprite = styleGroups.getSprite(spriteId);</span>

<span class="nc bnc" id="L1155" title="All 2 branches missed.">				if (sprite != null)</span>
<span class="nc" id="L1156">					sprite.detach();</span>
			}
		}
<span class="nc" id="L1159">	}</span>

	public GraphicSprite addSprite(String id) {
<span class="nc" id="L1162">		String prefix = String.format(&quot;ui.sprite.%s&quot;, id);</span>
<span class="nc" id="L1163">		logger.info(String.format(&quot;Added sprite %s.&quot;, id));</span>
<span class="nc" id="L1164">		setAttribute(prefix, 0, 0, 0);</span>
<span class="nc" id="L1165">		GraphicSprite s = styleGroups.getSprite(id);</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">		assert (s != null);</span>
<span class="nc" id="L1167">		return s;</span>
	}

	protected GraphicSprite addSprite_(String id) {
<span class="nc" id="L1171">		GraphicSprite s = new GraphicSprite(id, this);</span>
<span class="nc" id="L1172">		styleGroups.addElement(s);</span>
<span class="nc" id="L1173">		graphChanged = true;</span>

<span class="nc" id="L1175">		return s;</span>
	}

	public void removeSprite(String id) {
<span class="nc" id="L1179">		String prefix = String.format(&quot;ui.sprite.%s&quot;, id);</span>
<span class="nc" id="L1180">		removeAttribute(prefix);</span>
<span class="nc" id="L1181">	}</span>

	protected GraphicSprite removeSprite_(String id) {
<span class="nc" id="L1184">		GraphicSprite sprite = (GraphicSprite) styleGroups.getSprite(id);</span>

<span class="nc bnc" id="L1186" title="All 2 branches missed.">		if (sprite != null) {</span>
<span class="nc" id="L1187">			sprite.detach();</span>
<span class="nc" id="L1188">			styleGroups.removeElement(sprite);</span>
<span class="nc" id="L1189">			sprite.removed();</span>

<span class="nc" id="L1191">			graphChanged = true;</span>
		}

<span class="nc" id="L1194">		return sprite;</span>
	}

	protected void positionSprite(GraphicSprite sprite, Object value) {
<span class="nc bnc" id="L1198" title="All 2 branches missed.">		if (value instanceof Object[]) {</span>
<span class="nc" id="L1199">			Object[] values = (Object[]) value;</span>

<span class="nc bnc" id="L1201" title="All 2 branches missed.">			if (values.length == 4) {</span>
<span class="nc bnc" id="L1202" title="All 6 branches missed.">				if (values[0] instanceof Number &amp;&amp; values[1] instanceof Number &amp;&amp; values[2] instanceof Number</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">						&amp;&amp; values[3] instanceof Style.Units) {</span>
<span class="nc" id="L1204">					sprite.setPosition(((Number) values[0]).doubleValue(), ((Number) values[1]).doubleValue(),</span>
<span class="nc" id="L1205">							((Number) values[2]).doubleValue(), (Style.Units) values[3]);</span>
<span class="nc" id="L1206">				} else {</span>
<span class="nc" id="L1207">					logger.warning(&quot;Cannot parse values[4] for sprite position.&quot;);</span>
				}
<span class="nc bnc" id="L1209" title="All 2 branches missed.">			} else if (values.length == 3) {</span>
<span class="nc bnc" id="L1210" title="All 6 branches missed.">				if (values[0] instanceof Number &amp;&amp; values[1] instanceof Number &amp;&amp; values[2] instanceof Number) {</span>
<span class="nc" id="L1211">					sprite.setPosition(((Number) values[0]).doubleValue(), ((Number) values[1]).doubleValue(),</span>
<span class="nc" id="L1212">							((Number) values[2]).doubleValue(), Units.GU);</span>
<span class="nc" id="L1213">				} else {</span>
<span class="nc" id="L1214">					logger.warning(&quot;Cannot parse values[3] for sprite position.&quot;);</span>
				}
<span class="nc bnc" id="L1216" title="All 2 branches missed.">			} else if (values.length == 1) {</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">				if (values[0] instanceof Number) {</span>
<span class="nc" id="L1218">					sprite.setPosition(((Number) values[0]).doubleValue());</span>
<span class="nc" id="L1219">				} else {</span>
<span class="nc" id="L1220">					logger.warning(&quot;Sprite position percent is not a number.&quot;);</span>
				}
<span class="nc" id="L1222">			} else {</span>
<span class="nc" id="L1223">				logger.warning(String.format(&quot;Cannot transform value '%s' (length=%d) into a position%n&quot;,</span>
<span class="nc" id="L1224">						Arrays.toString(values), values.length));</span>
			}
<span class="nc bnc" id="L1226" title="All 2 branches missed.">		} else if (value instanceof Number) {</span>
<span class="nc" id="L1227">			sprite.setPosition(((Number) value).doubleValue());</span>
<span class="nc bnc" id="L1228" title="All 2 branches missed.">		} else if (value instanceof Value) {</span>
<span class="nc" id="L1229">			sprite.setPosition(((Value) value).value);</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">		} else if (value instanceof Values) {</span>
<span class="nc" id="L1231">			sprite.setPosition((Values) value);</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">		} else if (value == null) {</span>
<span class="nc" id="L1233">			throw new RuntimeException(&quot;What do you expect with a null value ?&quot;);</span>
		} else {
<span class="nc" id="L1235">			logger.warning(String.format(&quot;Cannot place sprite with posiiton '%s' (instance of %s)%n&quot;, value,</span>
<span class="nc" id="L1236">					value.getClass().getName()));</span>
		}
<span class="nc" id="L1238">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.stream.Source#clearAttributeSinks()
	 */
	@Override
	public void clearAttributeSinks() {
<span class="nc" id="L1247">		listeners.clearAttributeSinks();</span>
<span class="nc" id="L1248">	}</span>

	/*
	 * *(non-Javadoc)
	 * 
	 * @see org.graphstream.stream.Source#clearElementSinks()
	 */
	@Override
	public void clearElementSinks() {
<span class="nc" id="L1257">		listeners.clearElementSinks();</span>
<span class="nc" id="L1258">	}</span>

	/*
	 * (non-Javadoc)
	 * 
	 * @see org.graphstream.stream.Source#clearSinks()
	 */
	@Override
	public void clearSinks() {
<span class="nc" id="L1267">		listeners.clearSinks();</span>
<span class="nc" id="L1268">	}</span>

	// stubs for the new methods

	@Override
	public Edge addEdge(String id, int index1, int index2) {
<span class="nc" id="L1274">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	@Override
	public Edge addEdge(String id, int fromIndex, int toIndex, boolean directed) {
<span class="nc" id="L1279">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	@Override
	public Edge addEdge(String id, Node node1, Node node2) {
<span class="nc" id="L1284">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	@Override
	public Edge addEdge(String id, Node from, Node to, boolean directed) {
<span class="nc" id="L1289">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	@Override
	public Edge getEdge(int index) throws IndexOutOfBoundsException {
<span class="nc" id="L1294">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	@Override
	public Node getNode(int index) throws IndexOutOfBoundsException {
<span class="nc" id="L1299">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	@Override
	public Edge removeEdge(int index) {
<span class="nc" id="L1304">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	@Override
	public Edge removeEdge(int fromIndex, int toIndex) {
<span class="nc" id="L1309">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	@Override
	public Edge removeEdge(Node node1, Node node2) {
<span class="nc" id="L1314">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	@Override
	public Edge removeEdge(Edge edge) {
<span class="nc" id="L1319">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	@Override
	public Node removeNode(int index) {
<span class="nc" id="L1324">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	@Override
	public Node removeNode(Node node) {
<span class="nc" id="L1329">		throw new RuntimeException(&quot;not implemented !&quot;);</span>
	}

	/**
	 * Replay all the elements of the graph and all attributes as new events to all
	 * connected sinks.
	 * &lt;p&gt;
	 * Be very careful with this method, it introduces new events in the event
	 * stream and some sinks may therefore receive them twice !! Graph replay is
	 * always dangerous !
	 */
	public void replay() {
		// Replay all graph attributes.

<span class="nc" id="L1343">		attributeKeys().forEach(key -&gt; {</span>
<span class="nc" id="L1344">			listeners.sendGraphAttributeAdded(id, key, getAttribute(key));</span>
<span class="nc" id="L1345">		});</span>

		// Replay all nodes and their attributes.

<span class="nc" id="L1349">		nodes().forEach(node -&gt; {</span>
<span class="nc" id="L1350">			listeners.sendNodeAdded(id, node.getId());</span>

<span class="nc" id="L1352">			node.attributeKeys().forEach(key -&gt; {</span>
<span class="nc" id="L1353">				listeners.sendNodeAttributeAdded(id, node.getId(), key, node.getAttribute(key));</span>
<span class="nc" id="L1354">			});</span>
<span class="nc" id="L1355">		});</span>

		// Replay all edges and their attributes.

<span class="nc" id="L1359">		edges().forEach(edge -&gt; {</span>
<span class="nc" id="L1360">			listeners.sendEdgeAdded(id, edge.getId(), edge.getSourceNode().getId(), edge.getTargetNode().getId(),</span>
<span class="nc" id="L1361">					edge.isDirected());</span>

<span class="nc" id="L1363">			edge.attributeKeys().forEach(key -&gt; {</span>
<span class="nc" id="L1364">				listeners.sendEdgeAttributeAdded(id, edge.getId(), key, edge.getAttribute(key));</span>
<span class="nc" id="L1365">			});</span>
<span class="nc" id="L1366">		});</span>
<span class="nc" id="L1367">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span>src-test (6 de jul. de 2023 19:58:26)</div></body></html>